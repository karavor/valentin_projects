Программа генерирует олиги, которые теоретически не должны быть самоаффинными и
сворачиваться в шпильку.

Программа работает с нуклеотидными паттернами длины l_паттерна. С одной стороны
она не должна быть меньше размеров зон, которые определяют образование шпильки.
Т.е. к примеру не меньше 2-х. С другой стороны она должна быть в несколько раз меньше длины генерируемых олигов (м.б. меньше их доменов), т.е. 20-40 нукл.
Также с увеличением длины паттерна экспоненциально растет сложность вычислений
(но это не точно). Поэтому по умолчанию будем брать длину паттерна равной 4, а
в итоге проварьируем эту величину и посмотрим, при каком значении параметра
результаты будут лучше.

I

Подбираем олиги длиной в диапазоне [n_min*l_паттерна; n_max*l_паттерна]:
1. self_aff < self_aff_crit (порядка 0,5%) ( |dG_self| < 6 )
2. |dG|<|dG_crit|

Обозначения:
dG_max_n = dG ([G]_n + [C]_n)
dG_self = dG (olig + olig)

Для реализации этой задачи предложен следующий алгоритм.

1) Составляем базу всевозможных паттернов заданной длины (4^l_паттерна) и нумеруим их

2) Отбрасываем паттерны, у которых |dG_self|/|dG_max_l_паттерна| > crit_score
   и перенумировываем базу соотв. Здесь 0 < crit_score < 1

3) Составляем матрицу М, ячейкой которой М(i, k) является структура, содержащая:
   a) dG(i+k)/dG_max_l_паттерна
   b) номера паттернов (r, s, t), образованных при склейке паттернов i и k
      (всего их [l_паттерна - 1] штук)
   c) скоринг склейки паттернов ik, равный
      max{ М(i, k).a; М(i, r).a; М(i, s).a; ... } всевозм. сочетания патт. i, k, r, s, t

4) Составляем цепочки паттернов (длины до n_max паттернов), работая со склейками, у которых
   скоринг < crit_score, по следующему правилу
   а) Соединяем две соответсвующие склейки (например 1-3 и 3-5)
   b) Аналогично вычисляем скоринг получившейся цепочки
   с) Если удовл. усл., то продолжаем строить цепочку, если нет - обрываем

Например, при добавлении 4-го паттерна к цепочке из трех паттернов проверяем, чтобы
всевозможные сочетания паттернов, образующихся при склейке 1-2 и 2-3, с паттернами,
образующимися при склейке 3-4, удовл. упомянутым выше условиям.
т.е. смотрим пары

Сначала строим всевозможные допустимые цепочки по 3 паттерна, соединяя пары соответств. склеек,
затем к этим цепочкам ан-но пристраиваем соотв. склейки и получаем цепочки по 4 паттерна и т.д.

1-34а
12а-34а
12б-34а
12в-34а

2-34а
23а-34а
23б-34а
23в-34а

(ан-но с 34б, 34в, 4)

***

Более общая задача:
Формируя, размещения с повторениями из n по k (здесь n - кол-во всевозм. паттернов, а
k - кол-во паттернов в конечных олигах), по определенному правилу зачеркиваем текущее
размещение, при этом зачеркнутое размещение не должно встречаться далее, как часть
вновь сформированного размещения.

Поясним на примере при n = 3; k = 3:

0	0	00	0	000		0
				001!	1
				002!	2

		01!	1	010!	3
				011!	4
				012!	5

		02!	2	020!	6
				021!	7
				022!	8


1!	1	10!	3	100!	9
				101!	10
				102!	11

		11!	4	110!	12
				111!	13
				112!	14

		12!	5	120!	15
				121!	16
				122!	17


2	2	20	6	200		18
				201!	19
				202!	20

		21!	7	210!	21
				211!	22
				212!	23

		22	8	220		24
				221!	25
				222		26

Итого:	пусть при первой итерации, зачеркнутый номер 1, тогда при второй и последующих
		итерациях размещения, начинающиеся с 1 автоматически зачеркиваем по следующему
		правилу: если размещение запрещено на r-й итерации, тогда на (r+g)-й итерации
		зачеркиваем все номера в диапазоне от k до k + n^g - 1, где k - номер первого
		встретившегося размещения на g-й итерации, которое начинается с данного
		запрещенного размещения
		В частности, если у запрещенного размещения на r-й итерации номер f, тогда
		k = f*(n^g)

		Подытожим правило: если размещение запрещено на r-й итерации и имеет номер f,
		тогда на (r+g)-й итерации зачеркиваем все номера в диапазоне
		от (n^g)*f до (n^g)*(f + 1) - 1


		при второй итерации заметим, что 1 содержат размещения под номерами 1, 4, 7
		(3, 4 и 5 можно не учитывать, т.к. они и так начинаются с единицы)
		в общем же случае эти номера вычисляем по формуле: i = k + m*n,
		где m - неотриц. целое число, а
		    k - номер первого встретившегося размещения, заканчивающегося на 1,
		т.е. i - k кратно n

		после этого зачеркнем ещё к тому же (по тому же закону, по которому мы
		зачеркнули номер 1 при первой итерации) размещение 02, тогда при третьей
		итерации мы автоматом зачеркнем размещения, содержащие 02 под номерами 2, 11, 20
		(аналогично номера 6, 7, 8, в которых размещения начинаются с 02 автоматически зачеркиваем)
		т.е. i = k + m*(n^2) или i - k кратно n^2

		по такому же принципу зачеркиваем размещения, содержащие 01, 10, 11, 12, 21
		т.к. на предыдущей итерации мы их уже зачеркнули. Например для размещения 11 зачеркиваем
		(помимо очевидных размещений под номерами 12, 13, 14) 4-й и 22-й номер и вообще все,
		у которых i - 4 кратно n^2

		Подытожим правило: если размещение запрещено на r-й итерации и имеет номер f,
		тогда на (r+g)-й итерации зачеркиваем все номера i для которых вып. усл.

		(i - f) кратно n^r
		или
		i = f + m*(n^r), где m - неотриц. целое число

		Примечание: итерации нумеруем с 1, а не с 0 (т.е. r_min = 1)


		Программная реализация алгоритма:

		1) Составляем матрицу: в первой строке - номера итераций
							   по столбцам запрещенные номера размещений.

		2) Составляем массив структур: 1-й эл-т - номер размещения,
									   2-й эл-т - вектор номеров эл-тов размещения.

		3) Массив структур будем формировать при 1-й итерации и
		   модифицировать при последующих по принципу алгоритма A_n_k,
		   но с учетом выше выведенных правил.

		В частности, при модификации массива структур вновь добавляемый эл-т
		будет иметь номер предыдущего эл-та: i + 1
		(+ n^( r - g ), если i + 1 == (n^g)*f ), где
		r - номер текущей итерации
		f - номер запрещенного размещения на (r - g)-й итерации при g=g_max,
		    т.е. номер первого слева столбца, в котором встретился f есть (r - g)



   3) Составляем матрицу М, ячейкой которой М(i, k) является сродство склейки i и k паттернов
   самой к себе (равное, например dG(ik+ik)/dGmax8 ) + см. на dG(ik) и м.б. на самоафф.

   затем отбрасываем хреновые склейки, а после из оставшихся делаем склейки по 3 паттерна
   а дальше то же самое, что и до этого ...

3) Составляем цепочки паттернов (длины до n_max паттернов) по следующему правилу
   а) берем первый паттерн

II

Предполагаем, что финальные олиги
а) не будут самоаффинными, если они не будут содержать самоафф. паттернов
б) не будут сворачиваться в шпильку, если они не содержат аффинных (комплементарных
   полностью или частично) друг к другу пар паттернов.

   Для реализации этого подхода предложен следующий алгоритм.

1) Составляем базу всевозможных паттернов заданной длины (4^l_паттерна) и нумеруим их
2) Вводим ф-цию сродства паттернов друг к другу ( например dG(i+k)/dGmax4 )
3) Составляем матрицу М, ячейкой которой М(i, k) является структура, содержащая:
   а) значение ф-ции сродства паттернов i и k
   б) номера паттернов (r, s, t), образованных при склейке паттернов i и k
      (всего их [l_паттерна - 1] штук)
   в) скоринг склейки самой к себе, равный
      dG([ik]+[ik])/dGmax8
	  или
	  max{ dG(i+i), dG(k+k), 5/4*1/2*[ 2*dG(t+k) ], 6/4*1/3*[ 2*dG(k+s)+dG(t+t) ],
	       7/4*1/4[ 2*dG(k+r) + 2*dG(s+t) ], 8/4*1/5*[ 2*dG(i+k) + 2*dG(r+t) + dG(s+s) ], ... }

4) Составляем цепочки склеек по следующему правилу