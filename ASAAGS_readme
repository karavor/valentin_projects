Программа генерирует олиги, которые теоретически не должны быть самоаффинными и
сворачиваться в шпильку.

Программа работает с нуклеотидными паттернами длины l_паттерна. С одной стороны
она не должна быть меньше размеров зон, которые определяют образование шпильки.
Т.е. к примеру не меньше 2-х. С другой стороны она должна быть в несколько раз меньше длины генерируемых олигов (м.б. меньше их доменов), т.е. 20-40 нукл.
Также с увеличением длины паттерна экспоненциально растет сложность вычислений
(но это не точно). Поэтому по умолчанию будем брать длину паттерна равной 4, а
в итоге проварьируем эту величину и посмотрим, при каком значении параметра
результаты будут лучше.

I

Подбираем олиги длиной в диапазоне [n_min*l_паттерна; n_max*l_паттерна]:
1. self_aff < self_aff_crit (порядка 0,5%) ( |dG_self| < 6 )
2. |dG|<|dG_crit|

Обозначения:
dG_max_n = dG ([G]_n + [C]_n)
dG_self = dG (olig + olig)

Для реализации этой задачи предложен следующий алгоритм.

1) Составляем базу всевозможных паттернов заданной длины (4^l_паттерна) и нумеруим их

2) Отбрасываем паттерны, у которых |dG_self|/|dG_max_l_паттерна| > crit_score
   и перенумировываем базу соотв. Здесь 0 < crit_score < 1

3) Составляем матрицу М, ячейкой которой М(i, k) является структура, содержащая:
   a) dG(i+k)/dG_max_l_паттерна
   b) номера паттернов (r, s, t), образованных при склейке паттернов i и k
      (всего их [l_паттерна - 1] штук)
   c) скоринг склейки паттернов ik, равный
      max{ М(i, k).a; М(i, r).a; М(i, s).a; ... } всевозм. сочетания патт. i, k, r, s, t

4) Составляем цепочки паттернов (длины до n_max паттернов), работая со склейками, у которых
   скоринг < crit_score, по следующему правилу
   а) Соединяем две соответсвующие склейки (например 1-3 и 3-5)
   b) Аналогично вычисляем скоринг получившейся цепочки
   с) Если удовл. усл., то продолжаем строить цепочку, если нет - обрываем


***



   3) Составляем матрицу М, ячейкой которой М(i, k) является сродство склейки i и k паттернов
   самой к себе (равное, например dG(ik+ik)/dGmax8 ) + см. на dG(ik) и м.б. на самоафф.

   затем отбрасываем хреновые склейки, а после из оставшихся делаем склейки по 3 паттерна
   а дальше то же самое, что и до этого ...

3) Составляем цепочки паттернов (длины до n_max паттернов) по следующему правилу
   а) берем первый паттерн

II

Предполагаем, что финальные олиги
а) не будут самоаффинными, если они не будут содержать самоафф. паттернов
б) не будут сворачиваться в шпильку, если они не содержат аффинных (комплементарных
   полностью или частично) друг к другу пар паттернов.

   Для реализации этого подхода предложен следующий алгоритм.

1) Составляем базу всевозможных паттернов заданной длины (4^l_паттерна) и нумеруим их
2) Вводим ф-цию сродства паттернов друг к другу ( например dG(i+k)/dGmax4 )
3) Составляем матрицу М, ячейкой которой М(i, k) является структура, содержащая:
   а) значение ф-ции сродства паттернов i и k
   б) номера паттернов (r, s, t), образованных при склейке паттернов i и k
      (всего их [l_паттерна - 1] штук)
   в) скоринг склейки самой к себе, равный
      dG([ik]+[ik])/dGmax8
	  или
	  max{ dG(i+i), dG(k+k), 5/4*1/2*[ 2*dG(t+k) ], 6/4*1/3*[ 2*dG(k+s)+dG(t+t) ],
	       7/4*1/4[ 2*dG(k+r) + 2*dG(s+t) ], 8/4*1/5*[ 2*dG(i+k) + 2*dG(r+t) + dG(s+s) ], ... }

4) Составляем цепочки склеек по следующему правилу